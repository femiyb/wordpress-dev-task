{"version":3,"names":["_hpq","require","_memize","_interopRequireDefault","_compose","_hooks","_matchers","_utils","toBooleanAttributeMatcher","matcher","pipe","value","undefined","exports","isOfType","type","constructor","Object","Array","isArray","isOfTypes","types","some","getBlockAttribute","attributeKey","attributeSchema","innerDOM","commentAttributes","innerHTML","source","parseWithAttributeSchema","isValidByType","isValidByEnum","enum","default","enumSet","includes","matcherFromSource","memoize","sourceConfig","attr","selector","attribute","html","multiline","text","children","node","subMatchers","fromEntries","entries","query","map","key","subSourceConfig","prop","nodeName","toLowerCase","console","error","parseHtml","hpqParse","h","getBlockAttributes","blockTypeOrName","attributes","_blockType$attributes","doc","blockType","normalizeBlockType","blockAttributes","schema","applyFilters"],"sources":["@wordpress/blocks/src/api/parser/get-block-attributes.js"],"sourcesContent":["/**\n * External dependencies\n */\nimport { parse as hpqParse } from 'hpq';\nimport memoize from 'memize';\n\n/**\n * WordPress dependencies\n */\nimport { pipe } from '@wordpress/compose';\nimport { applyFilters } from '@wordpress/hooks';\n\n/**\n * Internal dependencies\n */\nimport { attr, html, text, query, node, children, prop } from '../matchers';\nimport { normalizeBlockType } from '../utils';\n\n/**\n * Higher-order hpq matcher which enhances an attribute matcher to return true\n * or false depending on whether the original matcher returns undefined. This\n * is useful for boolean attributes (e.g. disabled) whose attribute values may\n * be technically falsey (empty string), though their mere presence should be\n * enough to infer as true.\n *\n * @param {Function} matcher Original hpq matcher.\n *\n * @return {Function} Enhanced hpq matcher.\n */\nexport const toBooleanAttributeMatcher = ( matcher ) =>\n\tpipe( [\n\t\tmatcher,\n\t\t// Expected values from `attr( 'disabled' )`:\n\t\t//\n\t\t// <input>\n\t\t// - Value:       `undefined`\n\t\t// - Transformed: `false`\n\t\t//\n\t\t// <input disabled>\n\t\t// - Value:       `''`\n\t\t// - Transformed: `true`\n\t\t//\n\t\t// <input disabled=\"disabled\">\n\t\t// - Value:       `'disabled'`\n\t\t// - Transformed: `true`\n\t\t( value ) => value !== undefined,\n\t] );\n\n/**\n * Returns true if value is of the given JSON schema type, or false otherwise.\n *\n * @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25\n *\n * @param {*}      value Value to test.\n * @param {string} type  Type to test.\n *\n * @return {boolean} Whether value is of type.\n */\nexport function isOfType( value, type ) {\n\tswitch ( type ) {\n\t\tcase 'string':\n\t\t\treturn typeof value === 'string';\n\n\t\tcase 'boolean':\n\t\t\treturn typeof value === 'boolean';\n\n\t\tcase 'object':\n\t\t\treturn !! value && value.constructor === Object;\n\n\t\tcase 'null':\n\t\t\treturn value === null;\n\n\t\tcase 'array':\n\t\t\treturn Array.isArray( value );\n\n\t\tcase 'integer':\n\t\tcase 'number':\n\t\t\treturn typeof value === 'number';\n\t}\n\n\treturn true;\n}\n\n/**\n * Returns true if value is of an array of given JSON schema types, or false\n * otherwise.\n *\n * @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25\n *\n * @param {*}        value Value to test.\n * @param {string[]} types Types to test.\n *\n * @return {boolean} Whether value is of types.\n */\nexport function isOfTypes( value, types ) {\n\treturn types.some( ( type ) => isOfType( value, type ) );\n}\n\n/**\n * Given an attribute key, an attribute's schema, a block's raw content and the\n * commentAttributes returns the attribute value depending on its source\n * definition of the given attribute key.\n *\n * @param {string} attributeKey      Attribute key.\n * @param {Object} attributeSchema   Attribute's schema.\n * @param {Node}   innerDOM          Parsed DOM of block's inner HTML.\n * @param {Object} commentAttributes Block's comment attributes.\n * @param {string} innerHTML         Raw HTML from block node's innerHTML property.\n *\n * @return {*} Attribute value.\n */\nexport function getBlockAttribute(\n\tattributeKey,\n\tattributeSchema,\n\tinnerDOM,\n\tcommentAttributes,\n\tinnerHTML\n) {\n\tlet value;\n\n\tswitch ( attributeSchema.source ) {\n\t\t// An undefined source means that it's an attribute serialized to the\n\t\t// block's \"comment\".\n\t\tcase undefined:\n\t\t\tvalue = commentAttributes\n\t\t\t\t? commentAttributes[ attributeKey ]\n\t\t\t\t: undefined;\n\t\t\tbreak;\n\t\t// raw source means that it's the original raw block content.\n\t\tcase 'raw':\n\t\t\tvalue = innerHTML;\n\t\t\tbreak;\n\t\tcase 'attribute':\n\t\tcase 'property':\n\t\tcase 'html':\n\t\tcase 'text':\n\t\tcase 'children':\n\t\tcase 'node':\n\t\tcase 'query':\n\t\tcase 'tag':\n\t\t\tvalue = parseWithAttributeSchema( innerDOM, attributeSchema );\n\t\t\tbreak;\n\t}\n\n\tif (\n\t\t! isValidByType( value, attributeSchema.type ) ||\n\t\t! isValidByEnum( value, attributeSchema.enum )\n\t) {\n\t\t// Reject the value if it is not valid. Reverting to the undefined\n\t\t// value ensures the default is respected, if applicable.\n\t\tvalue = undefined;\n\t}\n\n\tif ( value === undefined ) {\n\t\tvalue = attributeSchema.default;\n\t}\n\n\treturn value;\n}\n\n/**\n * Returns true if value is valid per the given block attribute schema type\n * definition, or false otherwise.\n *\n * @see https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1.1\n *\n * @param {*}                       value Value to test.\n * @param {?(Array<string>|string)} type  Block attribute schema type.\n *\n * @return {boolean} Whether value is valid.\n */\nexport function isValidByType( value, type ) {\n\treturn (\n\t\ttype === undefined ||\n\t\tisOfTypes( value, Array.isArray( type ) ? type : [ type ] )\n\t);\n}\n\n/**\n * Returns true if value is valid per the given block attribute schema enum\n * definition, or false otherwise.\n *\n * @see https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1.2\n *\n * @param {*}      value   Value to test.\n * @param {?Array} enumSet Block attribute schema enum.\n *\n * @return {boolean} Whether value is valid.\n */\nexport function isValidByEnum( value, enumSet ) {\n\treturn ! Array.isArray( enumSet ) || enumSet.includes( value );\n}\n\n/**\n * Returns an hpq matcher given a source object.\n *\n * @param {Object} sourceConfig Attribute Source object.\n *\n * @return {Function} A hpq Matcher.\n */\nexport const matcherFromSource = memoize( ( sourceConfig ) => {\n\tswitch ( sourceConfig.source ) {\n\t\tcase 'attribute':\n\t\t\tlet matcher = attr( sourceConfig.selector, sourceConfig.attribute );\n\t\t\tif ( sourceConfig.type === 'boolean' ) {\n\t\t\t\tmatcher = toBooleanAttributeMatcher( matcher );\n\t\t\t}\n\n\t\t\treturn matcher;\n\t\tcase 'html':\n\t\t\treturn html( sourceConfig.selector, sourceConfig.multiline );\n\t\tcase 'text':\n\t\t\treturn text( sourceConfig.selector );\n\t\tcase 'children':\n\t\t\treturn children( sourceConfig.selector );\n\t\tcase 'node':\n\t\t\treturn node( sourceConfig.selector );\n\t\tcase 'query':\n\t\t\tconst subMatchers = Object.fromEntries(\n\t\t\t\tObject.entries( sourceConfig.query ).map(\n\t\t\t\t\t( [ key, subSourceConfig ] ) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tmatcherFromSource( subSourceConfig ),\n\t\t\t\t\t]\n\t\t\t\t)\n\t\t\t);\n\t\t\treturn query( sourceConfig.selector, subMatchers );\n\t\tcase 'tag':\n\t\t\treturn pipe( [\n\t\t\t\tprop( sourceConfig.selector, 'nodeName' ),\n\t\t\t\t( nodeName ) =>\n\t\t\t\t\tnodeName ? nodeName.toLowerCase() : undefined,\n\t\t\t] );\n\t\tdefault:\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error( `Unknown source type \"${ sourceConfig.source }\"` );\n\t}\n} );\n\n/**\n * Parse a HTML string into DOM tree.\n *\n * @param {string|Node} innerHTML HTML string or already parsed DOM node.\n *\n * @return {Node} Parsed DOM node.\n */\nfunction parseHtml( innerHTML ) {\n\treturn hpqParse( innerHTML, ( h ) => h );\n}\n\n/**\n * Given a block's raw content and an attribute's schema returns the attribute's\n * value depending on its source.\n *\n * @param {string|Node} innerHTML       Block's raw content.\n * @param {Object}      attributeSchema Attribute's schema.\n *\n * @return {*} Attribute value.\n */\nexport function parseWithAttributeSchema( innerHTML, attributeSchema ) {\n\treturn matcherFromSource( attributeSchema )( parseHtml( innerHTML ) );\n}\n\n/**\n * Returns the block attributes of a registered block node given its type.\n *\n * @param {string|Object} blockTypeOrName Block type or name.\n * @param {string|Node}   innerHTML       Raw block content.\n * @param {?Object}       attributes      Known block attributes (from delimiters).\n *\n * @return {Object} All block attributes.\n */\nexport function getBlockAttributes(\n\tblockTypeOrName,\n\tinnerHTML,\n\tattributes = {}\n) {\n\tconst doc = parseHtml( innerHTML );\n\tconst blockType = normalizeBlockType( blockTypeOrName );\n\n\tconst blockAttributes = Object.fromEntries(\n\t\tObject.entries( blockType.attributes ?? {} ).map(\n\t\t\t( [ key, schema ] ) => [\n\t\t\t\tkey,\n\t\t\t\tgetBlockAttribute( key, schema, doc, attributes, innerHTML ),\n\t\t\t]\n\t\t)\n\t);\n\n\treturn applyFilters(\n\t\t'blocks.getBlockAttributes',\n\t\tblockAttributes,\n\t\tblockType,\n\t\tinnerHTML,\n\t\tattributes\n\t);\n}\n"],"mappings":"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"}