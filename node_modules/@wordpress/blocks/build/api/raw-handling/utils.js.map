{"version":3,"names":["_deepmerge","_interopRequireDefault","require","_dom","_","_getRawTransforms","customMerge","key","srcValue","objValue","undefined","args","deepmerge","clone","getBlockContentSchemaFromTransforms","transforms","context","phrasingContentSchema","getPhrasingContentSchema","schemaArgs","isPaste","schemas","map","isMatch","blockName","schema","hasAnchorSupport","hasBlockSupport","Object","fromEntries","entries","value","attributes","all","getBlockContentSchema","getRawTransforms","isPlain","HTML","test","deepFilterNodeList","nodeList","filters","doc","Array","from","forEach","node","childNodes","item","contains","deepFilterHTML","document","implementation","createHTMLDocument","body","innerHTML","getSibling","which","sibling","isPhrasingContent","parentNode"],"sources":["@wordpress/blocks/src/api/raw-handling/utils.js"],"sourcesContent":["/**\n * External dependencies\n */\nimport deepmerge from 'deepmerge';\n\n/**\n * WordPress dependencies\n */\nimport { isPhrasingContent, getPhrasingContentSchema } from '@wordpress/dom';\n\n/**\n * Internal dependencies\n */\nimport { hasBlockSupport } from '..';\nimport { getRawTransforms } from './get-raw-transforms';\n\nconst customMerge = ( key ) => {\n\treturn ( srcValue, objValue ) => {\n\t\tswitch ( key ) {\n\t\t\tcase 'children': {\n\t\t\t\tif ( objValue === '*' || srcValue === '*' ) {\n\t\t\t\t\treturn '*';\n\t\t\t\t}\n\n\t\t\t\treturn { ...objValue, ...srcValue };\n\t\t\t}\n\t\t\tcase 'attributes':\n\t\t\tcase 'require': {\n\t\t\t\treturn [ ...( objValue || [] ), ...( srcValue || [] ) ];\n\t\t\t}\n\t\t\tcase 'isMatch': {\n\t\t\t\t// If one of the values being merge is undefined (matches everything),\n\t\t\t\t// the result of the merge will be undefined.\n\t\t\t\tif ( ! objValue || ! srcValue ) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// When merging two isMatch functions, the result is a new function\n\t\t\t\t// that returns if one of the source functions returns true.\n\t\t\t\treturn ( ...args ) => {\n\t\t\t\t\treturn objValue( ...args ) || srcValue( ...args );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn deepmerge( objValue, srcValue, {\n\t\t\tcustomMerge,\n\t\t\tclone: false,\n\t\t} );\n\t};\n};\n\nexport function getBlockContentSchemaFromTransforms( transforms, context ) {\n\tconst phrasingContentSchema = getPhrasingContentSchema( context );\n\tconst schemaArgs = { phrasingContentSchema, isPaste: context === 'paste' };\n\tconst schemas = transforms.map( ( { isMatch, blockName, schema } ) => {\n\t\tconst hasAnchorSupport = hasBlockSupport( blockName, 'anchor' );\n\n\t\tschema = typeof schema === 'function' ? schema( schemaArgs ) : schema;\n\n\t\t// If the block does not has anchor support and the transform does not\n\t\t// provides an isMatch we can return the schema right away.\n\t\tif ( ! hasAnchorSupport && ! isMatch ) {\n\t\t\treturn schema;\n\t\t}\n\n\t\tif ( ! schema ) {\n\t\t\treturn {};\n\t\t}\n\n\t\treturn Object.fromEntries(\n\t\t\tObject.entries( schema ).map( ( [ key, value ] ) => {\n\t\t\t\tlet attributes = value.attributes || [];\n\t\t\t\t// If the block supports the \"anchor\" functionality, it needs to keep its ID attribute.\n\t\t\t\tif ( hasAnchorSupport ) {\n\t\t\t\t\tattributes = [ ...attributes, 'id' ];\n\t\t\t\t}\n\t\t\t\treturn [\n\t\t\t\t\tkey,\n\t\t\t\t\t{\n\t\t\t\t\t\t...value,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tisMatch: isMatch ? isMatch : undefined,\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t} )\n\t\t);\n\t} );\n\n\treturn deepmerge.all( schemas, {\n\t\tcustomMerge,\n\t\tclone: false,\n\t} );\n}\n\n/**\n * Gets the block content schema, which is extracted and merged from all\n * registered blocks with raw transfroms.\n *\n * @param {string} context Set to \"paste\" when in paste context, where the\n *                         schema is more strict.\n *\n * @return {Object} A complete block content schema.\n */\nexport function getBlockContentSchema( context ) {\n\treturn getBlockContentSchemaFromTransforms( getRawTransforms(), context );\n}\n\n/**\n * Checks whether HTML can be considered plain text. That is, it does not contain\n * any elements that are not line breaks.\n *\n * @param {string} HTML The HTML to check.\n *\n * @return {boolean} Whether the HTML can be considered plain text.\n */\nexport function isPlain( HTML ) {\n\treturn ! /<(?!br[ />])/i.test( HTML );\n}\n\n/**\n * Given node filters, deeply filters and mutates a NodeList.\n *\n * @param {NodeList} nodeList The nodeList to filter.\n * @param {Array}    filters  An array of functions that can mutate with the provided node.\n * @param {Document} doc      The document of the nodeList.\n * @param {Object}   schema   The schema to use.\n */\nexport function deepFilterNodeList( nodeList, filters, doc, schema ) {\n\tArray.from( nodeList ).forEach( ( node ) => {\n\t\tdeepFilterNodeList( node.childNodes, filters, doc, schema );\n\n\t\tfilters.forEach( ( item ) => {\n\t\t\t// Make sure the node is still attached to the document.\n\t\t\tif ( ! doc.contains( node ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titem( node, doc, schema );\n\t\t} );\n\t} );\n}\n\n/**\n * Given node filters, deeply filters HTML tags.\n * Filters from the deepest nodes to the top.\n *\n * @param {string} HTML    The HTML to filter.\n * @param {Array}  filters An array of functions that can mutate with the provided node.\n * @param {Object} schema  The schema to use.\n *\n * @return {string} The filtered HTML.\n */\nexport function deepFilterHTML( HTML, filters = [], schema ) {\n\tconst doc = document.implementation.createHTMLDocument( '' );\n\n\tdoc.body.innerHTML = HTML;\n\n\tdeepFilterNodeList( doc.body.childNodes, filters, doc, schema );\n\n\treturn doc.body.innerHTML;\n}\n\n/**\n * Gets a sibling within text-level context.\n *\n * @param {Element} node  The subject node.\n * @param {string}  which \"next\" or \"previous\".\n */\nexport function getSibling( node, which ) {\n\tconst sibling = node[ `${ which }Sibling` ];\n\n\tif ( sibling && isPhrasingContent( sibling ) ) {\n\t\treturn sibling;\n\t}\n\n\tconst { parentNode } = node;\n\n\tif ( ! parentNode || ! isPhrasingContent( parentNode ) ) {\n\t\treturn;\n\t}\n\n\treturn getSibling( parentNode, which );\n}\n"],"mappings":"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"}