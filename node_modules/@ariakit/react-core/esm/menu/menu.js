"use client";
import {
  useMenuList
} from "../__chunks/4KTUOVEM.js";
import {
  useMenuProviderContext
} from "../__chunks/YGMEBI3A.js";
import "../__chunks/KA4GX64Z.js";
import "../__chunks/HBGJOTTX.js";
import "../__chunks/FHDXHZLB.js";
import "../__chunks/6QXBPV75.js";
import "../__chunks/IB7YUKH5.js";
import "../__chunks/4UUKJZ4V.js";
import {
  useHovercard
} from "../__chunks/YGJUONJM.js";
import "../__chunks/YMV43K4F.js";
import "../__chunks/KB2HXEVC.js";
import {
  createDialogComponent
} from "../__chunks/U7WGY7YX.js";
import "../__chunks/JSLLR7RC.js";
import "../__chunks/CLF4PQ7T.js";
import "../__chunks/BULCTPRV.js";
import "../__chunks/6BJGLK2C.js";
import "../__chunks/CS347UVZ.js";
import "../__chunks/IUB2BTEK.js";
import "../__chunks/XHJGS6Z5.js";
import "../__chunks/TL67WVI6.js";
import "../__chunks/MKDDWKFK.js";
import "../__chunks/OOBDFMJL.js";
import "../__chunks/677M2CI3.js";
import "../__chunks/6GXEOXGT.js";
import "../__chunks/72E5EPFF.js";
import "../__chunks/X6WIMZJE.js";
import "../__chunks/HPP6CWMY.js";
import "../__chunks/UYRJLDVS.js";
import "../__chunks/E3XM3D67.js";
import "../__chunks/CHKJ74UC.js";
import "../__chunks/7452U3HH.js";
import "../__chunks/XPF5GU3Q.js";
import "../__chunks/FSFPRQFR.js";
import "../__chunks/A7CE3X6M.js";
import "../__chunks/TI7CMBHW.js";
import "../__chunks/7H5KSHHF.js";
import "../__chunks/G6BJYYBK.js";
import "../__chunks/OAYFXAQ2.js";
import "../__chunks/KK7H3W2B.js";
import "../__chunks/SHA3WOPI.js";
import "../__chunks/BG6HZDS7.js";
import {
  createComponent,
  createElement,
  createHook
} from "../__chunks/3ORBWXWF.js";
import "../__chunks/2N7L2ZZE.js";
import "../__chunks/CVWFS4PP.js";
import "../__chunks/XF5ITC6P.js";
import {
  useMergeRefs
} from "../__chunks/6O5OEQGF.js";
import "../__chunks/XM66DUTO.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "../__chunks/4R3V3JGP.js";

// src/menu/menu.tsx
import { createRef, useEffect, useRef, useState } from "react";
import { hasFocusWithin } from "@ariakit/core/utils/focus";
import { invariant, isFalsyBooleanCallback } from "@ariakit/core/utils/misc";
var useMenu = createHook(
  (_a) => {
    var _b = _a, {
      store,
      modal: modalProp = false,
      portal = !!modalProp,
      hideOnEscape = true,
      autoFocusOnShow = true,
      hideOnHoverOutside,
      alwaysVisible
    } = _b, props = __objRest(_b, [
      "store",
      "modal",
      "portal",
      "hideOnEscape",
      "autoFocusOnShow",
      "hideOnHoverOutside",
      "alwaysVisible"
    ]);
    const context = useMenuProviderContext();
    store = store || context;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "Menu must receive a `store` prop or be wrapped in a MenuProvider component."
    );
    const ref = useRef(null);
    const parentMenu = store.parent;
    const parentMenubar = store.menubar;
    const hasParentMenu = !!parentMenu;
    const parentIsMenubar = !!parentMenubar && !hasParentMenu;
    props = __spreadProps(__spreadValues({}, props), {
      ref: useMergeRefs(ref, props.ref)
    });
    const _a2 = useMenuList(
      __spreadValues({ store, alwaysVisible }, props)
    ), { "aria-labelledby": ariaLabelledBy } = _a2, menuListProps = __objRest(_a2, ["aria-labelledby"]);
    props = menuListProps;
    const [initialFocusRef, setInitialFocusRef] = useState();
    const autoFocusOnShowState = store.useState("autoFocusOnShow");
    const initialFocus = store.useState("initialFocus");
    const baseElement = store.useState("baseElement");
    const items = store.useState("renderedItems");
    useEffect(() => {
      let cleaning = false;
      setInitialFocusRef((prevInitialFocusRef) => {
        var _a3, _b2, _c;
        if (cleaning)
          return;
        if (!autoFocusOnShowState)
          return;
        if ((_a3 = prevInitialFocusRef == null ? void 0 : prevInitialFocusRef.current) == null ? void 0 : _a3.isConnected)
          return prevInitialFocusRef;
        const ref2 = createRef();
        switch (initialFocus) {
          case "first":
            ref2.current = ((_b2 = items.find((item) => !item.disabled && item.element)) == null ? void 0 : _b2.element) || null;
            break;
          case "last":
            ref2.current = ((_c = [...items].reverse().find((item) => !item.disabled && item.element)) == null ? void 0 : _c.element) || null;
            break;
          default:
            ref2.current = baseElement;
        }
        if (!ref2.current)
          return;
        return ref2;
      });
      return () => {
        cleaning = true;
      };
    }, [store, autoFocusOnShowState, initialFocus, items, baseElement]);
    const modal = hasParentMenu ? false : modalProp;
    const mayAutoFocusOnShow = !!autoFocusOnShow;
    const canAutoFocusOnShow = !!initialFocusRef || !!props.initialFocus || !!modal;
    props = useHovercard(__spreadProps(__spreadValues({
      store,
      alwaysVisible,
      initialFocus: initialFocusRef,
      autoFocusOnShow: mayAutoFocusOnShow ? canAutoFocusOnShow && autoFocusOnShow : autoFocusOnShowState || !!modal
    }, props), {
      hideOnEscape: (event) => {
        if (isFalsyBooleanCallback(hideOnEscape, event))
          return false;
        store == null ? void 0 : store.hideAll();
        return true;
      },
      hideOnHoverOutside: (event) => {
        if (typeof hideOnHoverOutside === "function") {
          return hideOnHoverOutside(event);
        }
        if (hideOnHoverOutside != null)
          return hideOnHoverOutside;
        if (hasParentMenu) {
          parentMenu.setActiveId(null);
          return true;
        }
        if (!parentIsMenubar)
          return false;
        const disclosure = store == null ? void 0 : store.getState().disclosureElement;
        if (!disclosure)
          return true;
        if (hasFocusWithin(disclosure))
          return false;
        return true;
      },
      modal,
      portal,
      backdrop: hasParentMenu ? false : props.backdrop
    }));
    props = __spreadValues({
      "aria-labelledby": ariaLabelledBy
    }, props);
    return props;
  }
);
var Menu = createDialogComponent(
  createComponent((props) => {
    const htmlProps = useMenu(props);
    return createElement("div", htmlProps);
  }),
  useMenuProviderContext
);
if (process.env.NODE_ENV !== "production") {
  Menu.displayName = "Menu";
}
export {
  Menu,
  useMenu
};
