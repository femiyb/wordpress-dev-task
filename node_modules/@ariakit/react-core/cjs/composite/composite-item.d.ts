import type { KeyboardEvent } from "react";
import type { BooleanOrCallback } from "@ariakit/core/utils/types";
import type { CollectionItemOptions } from "../collection/collection-item.js";
import type { CommandOptions } from "../command/command.js";
import type { As, Props } from "../utils/types.js";
import type { CompositeStore } from "./composite-store.js";
/**
 * Returns props to create a `CompositeItem` component.
 * @see https://ariakit.org/components/composite
 * @example
 * ```jsx
 * const store = useCompositeStore();
 * const props = useCompositeItem({ store });
 * <Role {...props}>Item 1</Role>
 * ```
 */
export declare const useCompositeItem: import("../utils/types.js").Hook<CompositeItemOptions<"button">>;
/**
 * Renders a composite item.
 * @see https://ariakit.org/components/composite
 * @example
 * ```jsx
 * const composite = useCompositeStore();
 * <Composite store={composite}>
 *   <CompositeItem>Item 1</CompositeItem>
 *   <CompositeItem>Item 2</CompositeItem>
 *   <CompositeItem>Item 3</CompositeItem>
 * </Composite>
 * ```
 */
export declare const CompositeItem: import("../utils/types.js").Component<CompositeItemOptions<"button">>;
export interface CompositeItemOptions<T extends As = "button"> extends CommandOptions<T>, CollectionItemOptions<T> {
    /**
     * Object returned by the
     * [`useCompositeStore`](https://ariakit.org/reference/use-composite-store)
     * hook. If not provided, the closest
     * [`Composite`](https://ariakit.org/reference/composite) or
     * [`CompositeProvider`](https://ariakit.org/reference/composite-provider)
     * components' context will be used.
     */
    store?: CompositeStore;
    /**
     * The id that will be used to group items in the same row. This is usually
     * retrieved by the
     * [`CompositeRow`](https://ariakit.org/reference/composite-row) component
     * through context so in most cases you don't need to set it manually.
     */
    rowId?: string;
    /**
     * Whether the scroll behavior should be prevented when pressing arrow keys on
     * the first or the last items.
     * @default false
     */
    preventScrollOnKeyDown?: BooleanOrCallback<KeyboardEvent<HTMLElement>>;
    /**
     * Whether pressing arrow keys should move the focus to a different item.
     * @default true
     */
    moveOnKeyPress?: BooleanOrCallback<KeyboardEvent<HTMLElement>>;
    /**
     * When the `tabbable` prop is set to `true`, the [roving
     * tabindex](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex)
     * method is partially disabled for this element. This means that the
     * `tabIndex` prop won't be assigned `-1` when the item is inactive. In
     * addition to using arrow keys, users will be able to tab to this element,
     * leading to the composite widget no longer existing as a single tab stop.
     *
     * As per the [ARIA spec](https://w3c.github.io/aria/#composite):
     *
     * > Authors **SHOULD** ensure that a composite widget exists as a single
     * > navigation stop within the larger navigation system of the web page.
     *
     * Additionally, as stated in
     * [RFC-2119](https://www.rfc-editor.org/rfc/rfc2119.txt):
     *
     * > **SHOULD** This word, or the adjective "RECOMMENDED", mean that there may
     * > exist valid reasons in particular circumstances to ignore a particular
     * > item, but the full implications must be understood and carefully weighed
     * > before choosing a different course.
     *
     * Therefore, while this may be allowed, you should think carefully about the
     * implications of using this prop.
     *
     * **Note**: This prop has no effect when the
     * [`virtualFocus`](https://ariakit.org/reference/composite-provider#virtualfocus)
     * option is enabled.
     */
    tabbable?: boolean;
}
export type CompositeItemProps<T extends As = "button"> = Props<CompositeItemOptions<T>>;
